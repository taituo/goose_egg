#!/usr/bin/env bash
# Codex best practice: keep bootstrap steps idempotent and tmux-friendly.
set -euo pipefail

# goose-egg.sh â€” bootstrap everything without breaking Markdown fences.

# -----------------------------
# Hardcoded settings (edit if needed)
# -----------------------------
PROJECT_ROOT="{{PROJECT_ROOT}}"
MODULE_PATH="{{MODULE_PATH}}"
SESSION_NAME="{{SESSION_NAME}}"
EDITOR_CMD="{{EDITOR_CMD}}"
MODEL_NAME="{{MODEL_NAME}}"

# -----------------------------
# Egg metadata (for verification & extraction)
# -----------------------------
EGG_NAME="{{EGG_NAME}}"
EGG_SCHEMA="{{EGG_SCHEMA}}"
EGG_DESCRIPTION="{{EGG_DESCRIPTION}}"
VARIANT_NAME="{{VARIANT_NAME}}"
VARIANT_TARGET="{{VARIANT_TARGET}}"
VARIANT_PROFILE="{{VARIANT_PROFILE}}"
VARIANT_PROVIDER="{{VARIANT_PROVIDER}}"
EGG_PAYLOAD_SHA256="{{EGG_PAYLOAD_SHA256}}"

# -----------------------------
# Runtime flags (defaults)
#   --exec              -> Codex non-interactive one-shot
#   --kill-codex-first  -> (no-op) preserved for compatibility; prints a note
#   --skip-codex        -> skip Codex stage entirely
# -----------------------------
CODEX_MODE="interactive"   # or "exec"
KILL_CODEX_FIRST="no"
SKIP_CODEX="no"
VERIFY_EGG="no"
EXTRACT_EGG_DEST=""

while [ $# -gt 0 ]; do
  case "$1" in
    --exec)
      CODEX_MODE="exec"
      shift
      ;;
    --kill-codex-first)
      KILL_CODEX_FIRST="yes"
      shift
      ;;
    --skip-codex)
      SKIP_CODEX="yes"
      shift
      ;;
    --verify-egg)
      VERIFY_EGG="yes"
      shift
      ;;
    --extract-egg)
      EXTRACT_EGG_DEST="egg_payload"
      shift
      if [ $# -gt 0 ] && [[ "$1" != --* ]]; then
        EXTRACT_EGG_DEST="$1"
        shift
      fi
      ;;
    --extract-egg=*)
      EXTRACT_EGG_DEST="${1#--extract-egg=}"
      shift
      ;;
    --help)
      cat <<'EO_HELP'
Usage: ./goose_egg.sh [flags]

  --exec               Run Codex in exec (one-shot) mode after scaffolding.
  --kill-codex-first   Preserve compatibility; prints reminder only.
  --skip-codex         Skip launching Codex entirely.
  --verify-egg         Verify embedded egg manifest and exit.
  --extract-egg[=DIR]  Recover the egg payload into DIR (default: ./egg_payload) and exit.
EO_HELP
      exit 0
      ;;
    *)
      echo "Unknown flag: $1" >&2
      echo "Supported: --exec | --kill-codex-first | --skip-codex | --verify-egg | --extract-egg[=DIR]" >&2
      exit 1
      ;;
  esac
done

# -----------------------------
# Helpers
# -----------------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
have() { command -v "$1" >/dev/null 2>&1; }

# Usage:
# write_if_absent "path/to/file" <<'EOF'
# ...contents...
# EOF
write_if_absent() {
  local path="$1"
  if [ -f "$path" ]; then
    echo "[i] Exists, not overwriting: $path"
  else
    mkdir -p "$(dirname "$path")"
    # shellcheck disable=SC2094
    cat > "$path"
    echo "[i] Created: $path"
  fi
}

commit_if_changes() {
  if ! git diff --quiet --cached || ! git diff --quiet; then
    git add -A
    if ! git diff --cached --quiet; then
      git commit -m "$1"
      echo "[i] Commit done: $1"
    else
      echo "[i] Nothing to commit."
    fi
  else
    echo "[i] No changes."
  fi
}

TODAY="$(date +%F)"

read_egg_payload() {
  cat <<'EO_EGG_PAYLOAD'
{{EGG_PAYLOAD_B64}}
EO_EGG_PAYLOAD
}

read_egg_manifest() {
  cat <<'EO_EGG_MANIFEST'
{{EGG_MANIFEST_JSON}}
EO_EGG_MANIFEST
}

ensure_python() {
  if ! have python3; then
    echo "[e] python3 is required for egg verification and extraction." >&2
    exit 1
  fi
}

run_egg_tool() {
  ensure_python
  local mode="$1"
  local destination="${2:-.}"
  local payload_file manifest_file
  payload_file="$(mktemp)"
  manifest_file="$(mktemp)"
  read_egg_payload >"$payload_file"
  read_egg_manifest >"$manifest_file"
  python3 - "$mode" "$payload_file" "$manifest_file" "$EGG_PAYLOAD_SHA256" "$destination" <<'PY'
import base64
import hashlib
import io
import json
import sys
import tarfile
from pathlib import Path

mode, payload_path, manifest_path, expected_sha, destination = sys.argv[1:6]

with open(payload_path, "r", encoding="utf-8") as handle:
    payload_bytes = base64.b64decode(handle.read().encode())

payload_hash = hashlib.sha256(payload_bytes).hexdigest()
if payload_hash != expected_sha:
    print("[e] Egg payload SHA mismatch", file=sys.stderr)
    sys.exit(1)

with open(manifest_path, "r", encoding="utf-8") as handle:
    manifest = json.load(handle)

buffer = io.BytesIO(payload_bytes)
with tarfile.open(fileobj=buffer, mode="r:gz") as archive:
    members = {member.name: member for member in archive.getmembers() if member.isfile()}
    manifest_names = set(manifest.keys())
    member_names = set(members.keys())

    extra_members = sorted(member_names - manifest_names)
    missing_members = sorted(manifest_names - member_names)

    if extra_members:
        print(f"[e] Payload contains files missing in manifest: {', '.join(extra_members)}", file=sys.stderr)
        sys.exit(1)
    if missing_members:
        print(f"[e] Manifest references missing files: {', '.join(missing_members)}", file=sys.stderr)
        sys.exit(1)

    for name, member in members.items():
        path_parts = Path(name).parts
        if name.startswith("/") or ".." in path_parts:
            print(f"[e] Unsafe path in payload: {name}", file=sys.stderr)
            sys.exit(1)
        extracted = archive.extractfile(member)
        if extracted is None:
            print(f"[e] Unable to read payload member: {name}", file=sys.stderr)
            sys.exit(1)
        try:
            data = extracted.read()
        finally:
            extracted.close()
        digest = hashlib.sha256(data).hexdigest()
        expected = manifest[name]
        if digest != expected:
            print(f"[e] Checksum mismatch for {name}", file=sys.stderr)
            sys.exit(1)

if mode == "verify":
    sys.exit(0)

destination_path = Path(destination)
destination_path.mkdir(parents=True, exist_ok=True)
destination_root = destination_path.resolve()

buffer = io.BytesIO(payload_bytes)
with tarfile.open(fileobj=buffer, mode="r:gz") as archive:
    for member in archive.getmembers():
        target = destination_path / member.name
        target_resolved = target.resolve()
        if not target_resolved.is_relative_to(destination_root):
            print(f"[e] Unsafe extraction target for {member.name}", file=sys.stderr)
            sys.exit(1)
        if member.isdir():
            target.mkdir(parents=True, exist_ok=True)
        elif member.isfile():
            target.parent.mkdir(parents=True, exist_ok=True)
            extracted = archive.extractfile(member)
            if extracted is None:
                print(f"[e] Unable to read payload member: {member.name}", file=sys.stderr)
                sys.exit(1)
            try:
                data = extracted.read()
            finally:
                extracted.close()
            with open(target, "wb") as handle:
                handle.write(data)
        else:
            print(f"[e] Unsupported tar entry type for {member.name}", file=sys.stderr)
            sys.exit(1)
PY
  local status=$?
  rm -f "$payload_file" "$manifest_file"
  return $status
}

verify_egg_payload() {
  if run_egg_tool verify "."; then
    echo "[i] Egg payload verified (${EGG_NAME:-unknown} :: ${VARIANT_NAME:-default})."
  else
    echo "[e] Egg verification failed." >&2
    return 1
  fi
}

extract_egg() {
  local destination="$1"
  if run_egg_tool extract "$destination"; then
    echo "[i] Egg verified (${EGG_NAME:-unknown} :: ${VARIANT_NAME:-default}) and extracted to $destination"
  else
    echo "[e] Failed to extract egg to $destination" >&2
    return 1
  fi
}

if [ -n "$EXTRACT_EGG_DEST" ]; then
  extract_egg "$EXTRACT_EGG_DEST" || exit 1
  exit 0
fi

if [ "$VERIFY_EGG" = "yes" ]; then
  verify_egg_payload || exit 1
  exit 0
fi

echo "[i] Egg: ${EGG_NAME:-unknown} (schema ${EGG_SCHEMA:-v1}, variant ${VARIANT_NAME:-default})"
if [ -n "${VARIANT_TARGET}${VARIANT_PROFILE}${VARIANT_PROVIDER}" ]; then
  echo "[i] Variant target=${VARIANT_TARGET:-n/a} profile=${VARIANT_PROFILE:-n/a} provider=${VARIANT_PROVIDER:-n/a}"
fi

# -----------------------------
# Dependencies
# -----------------------------
need git
need go
need tmux
# codex optional: may be skipped
if ! have codex; then
  echo "[w] codex not found; you can install/login later. (Use --skip-codex to silence this.)"
fi

# -----------------------------
# Repo init
# -----------------------------
mkdir -p "$PROJECT_ROOT"
cd "$PROJECT_ROOT"

if [ -d .git ]; then
  echo "[i] Git repo already exists at: $PROJECT_ROOT"
else
  echo "[i] Initializing empty repo at: $PROJECT_ROOT"
  git init
fi

# Detect current default branch (main/master...)
DEFAULT_BRANCH="$(git symbolic-ref --short HEAD 2>/dev/null || echo main)"

# -----------------------------
# Minimal Go stub (create only if missing)
# -----------------------------
if [ ! -f go.mod ]; then
  echo "[i] Creating Go module + minimal stub"
  go mod init "$MODULE_PATH" >/dev/null 2>&1 || true
else
  echo "[i] go.mod exists, skipping go mod init"
fi

write_if_absent "main.go" <<'EO_MAIN'
{{MAIN_GO}}
EO_MAIN

# First commit on default branch if repo is empty
git add -A || true
if git rev-parse --verify HEAD >/dev/null 2>&1; then
  echo "[i] Repository already has commits."
else
  git commit -m "chore: init stub (goose)"
fi

# -----------------------------
# Switch/create dev branch
# -----------------------------
if git rev-parse --verify dev >/dev/null 2>&1; then
  git switch dev
else
  git switch -c dev
fi

echo "[i] Creating repository layout and docs (no triple-backtick fences inside files)"

# -----------------------------
# Docs (create only if missing)
# -----------------------------
write_if_absent "SPEC.md" <<'EO_SPEC'
{{SPEC_MD}}
EO_SPEC

write_if_absent "CLI.md" <<'EO_CLI'
{{CLI_MD}}
EO_CLI

write_if_absent "ROLE.md" <<'EO_ROLE'
{{ROLE_MD}}
EO_ROLE

write_if_absent "OPERATIONS.md" <<'EO_OPS'
{{OPERATIONS_MD}}
EO_OPS

write_if_absent "README.md" <<'EO_README'
{{README_MD}}
EO_README

# -----------------------------
# Tasks and handoffs (on dev)
# -----------------------------
mkdir -p tasks handoffs/outbox personas

write_if_absent "tasks/TASK-001-login-api.md" <<'EO_TASK1'
{{TASK1_MD}}
EO_TASK1

write_if_absent "handoffs/inbox.md" <<'EO_INBOX'
{{INBOX_MD}}
EO_INBOX

write_if_absent "handoffs/outbox/GOOSE.md" <<'EO_GOOSE_OB'
{{GOOSE_OB}}
EO_GOOSE_OB

write_if_absent "handoffs/outbox/MAVERICK.md" <<'EO_MAV_OB'
{{MAVERICK_OB}}
EO_MAV_OB

# .gitignore (small starter)
write_if_absent ".gitignore" <<'EO_IGN'
{{GITIGNORE}}
EO_IGN

commit_if_changes "docs: scaffold goose spec/cli/roles/ops + tasks and handoffs (dev)"

# -----------------------------
# Codex (default interactive; optional exec)
# -----------------------------
if [ "${SKIP_CODEX}" = "no" ]; then
  if have codex; then
    if [ "${KILL_CODEX_FIRST}" = "yes" ]; then
      echo "[i] --kill-codex-first set, but automatic process kill was removed. Please close existing Codex processes manually if needed."
    fi

    CODEX_PROMPT='Read SPEC.md, CLI.md, ROLE.md, and OPERATIONS.md. Implement the next minimal increment for the goose CLI that satisfies the MUST-have items (session, worktrees, handoffs, radio, and AI flags) in small, testable steps. Keep it tmux and vim friendly, with no GUI and no external project references. Update README with usage.'

    if [ "$CODEX_MODE" = "exec" ]; then
      echo "[i] Running Codex (exec, one-shot, dangerous bypass)"
      set +e
      codex exec \
        --cd "$PROJECT_ROOT" \
        --dangerously-bypass-approvals-and-sandbox \
        -m "$MODEL_NAME" \
        "$CODEX_PROMPT"
      CODEX_RC=$?
      set -e
      if [ "$CODEX_RC" -ne 0 ]; then
        echo "[w] codex exec failed (rc=$CODEX_RC). Continuing."
      fi
    else
      echo "[i] Starting Codex (interactive, dangerous bypass). Close it when done."
      echo "[i] Tip: you can always resume later with: codex resume --last"
      set +e
      codex \
        --cd "$PROJECT_ROOT" \
        --dangerously-bypass-approvals-and-sandbox \
        -m "$MODEL_NAME" \
        "$CODEX_PROMPT"
      CODEX_RC=$?
      set -e
      if [ "$CODEX_RC" -ne 0 ]; then
        echo "[w] interactive Codex exited with rc=$CODEX_RC."
      fi
    fi
  else
    echo "[w] codex not found; skipping Codex run."
  fi
else
  echo "[i] Skipping Codex stage by request."
fi

echo
echo "Next:"
echo "  1) Inspect changes: git status && git log --oneline -n 5"
echo "  2) Build locally:   go build -o goose ."
echo "  3) Start session:   ./goose session start --repo . --session \"$SESSION_NAME\" --editor \"$EDITOR_CMD\" --ops"
echo "  4) Start Codex pane: codex -m \"$MODEL_NAME\" --cd \"$PROJECT_ROOT\""
echo "     (or re-run this script with --exec for one-shot Codex)"
